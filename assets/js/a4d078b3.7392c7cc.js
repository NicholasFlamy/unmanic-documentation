"use strict";(self.webpackChunkunmanic_documentation=self.webpackChunkunmanic_documentation||[]).push([[888],{3905:function(e,n,r){r.d(n,{Zo:function(){return s},kt:function(){return m}});var t=r(7294);function a(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function o(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,t)}return r}function i(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?o(Object(r),!0).forEach((function(n){a(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function c(e,n){if(null==e)return{};var r,t,a=function(e,n){if(null==e)return{};var r,t,a={},o=Object.keys(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||(a[r]=e[r]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(t=0;t<o.length;t++)r=o[t],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=t.createContext({}),u=function(e){var n=t.useContext(l),r=n;return e&&(r="function"==typeof e?e(n):i(i({},n),e)),r},s=function(e){var n=u(e.components);return t.createElement(l.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},p=t.forwardRef((function(e,n){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),p=u(r),m=a,f=p["".concat(l,".").concat(m)]||p[m]||d[m]||o;return r?t.createElement(f,i(i({ref:n},s),{},{components:r})):t.createElement(f,i({ref:n},s))}));function m(e,n){var r=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=p;var c={};for(var l in n)hasOwnProperty.call(n,l)&&(c[l]=n[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var u=2;u<o;u++)i[u]=r[u];return t.createElement.apply(null,i)}return t.createElement.apply(null,r)}p.displayName="MDXCreateElement"},8215:function(e,n,r){var t=r(7294);n.Z=function(e){var n=e.children,r=e.hidden,a=e.className;return t.createElement("div",{role:"tabpanel",hidden:r,className:a},n)}},6396:function(e,n,r){r.d(n,{Z:function(){return p}});var t=r(3117),a=r(7294),o=r(2389),i=r(9443);var c=function(){var e=(0,a.useContext)(i.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},l=r(9521),u=r(6010),s="tabItem_1uMI";function d(e){var n,r,t,o=e.lazy,i=e.block,d=e.defaultValue,p=e.values,m=e.groupId,f=e.className,v=a.Children.map(e.children,(function(e){if((0,a.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),h=null!=p?p:v.map((function(e){var n=e.props;return{value:n.value,label:n.label}})),I=(0,l.lx)(h,(function(e,n){return e.value===n.value}));if(I.length>0)throw new Error('Docusaurus error: Duplicate values "'+I.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var b=null===d?d:null!=(n=null!=d?d:null==(r=v.find((function(e){return e.props.default})))?void 0:r.props.value)?n:null==(t=v[0])?void 0:t.props.value;if(null!==b&&!h.some((function(e){return e.value===b})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+b+'" but none of its children has the corresponding value. Available values are: '+h.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var g=c(),_=g.tabGroupChoices,k=g.setTabGroupChoices,E=(0,a.useState)(b),w=E[0],y=E[1],N=[],D=(0,l.o5)().blockElementScrollPositionUntilNextRender;if(null!=m){var C=_[m];null!=C&&C!==w&&h.some((function(e){return e.value===C}))&&y(C)}var O=function(e){var n=e.currentTarget,r=N.indexOf(n),t=h[r].value;t!==w&&(D(n),y(t),null!=m&&k(m,t))},V=function(e){var n,r=null;switch(e.key){case"ArrowRight":var t=N.indexOf(e.currentTarget)+1;r=N[t]||N[0];break;case"ArrowLeft":var a=N.indexOf(e.currentTarget)-1;r=N[a]||N[N.length-1]}null==(n=r)||n.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,u.Z)("tabs",{"tabs--block":i},f)},h.map((function(e){var n=e.value,r=e.label;return a.createElement("li",{role:"tab",tabIndex:w===n?0:-1,"aria-selected":w===n,className:(0,u.Z)("tabs__item",s,{"tabs__item--active":w===n}),key:n,ref:function(e){return N.push(e)},onKeyDown:V,onFocus:O,onClick:O},null!=r?r:n)}))),o?(0,a.cloneElement)(v.filter((function(e){return e.props.value===w}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},v.map((function(e,n){return(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==w})}))))}function p(e){var n=(0,o.Z)();return a.createElement(d,(0,t.Z)({key:String(n)},e))}},9443:function(e,n,r){var t=(0,r(7294).createContext)(void 0);n.Z=t},9944:function(e,n,r){r.r(n),r.d(n,{frontMatter:function(){return u},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return p},default:function(){return f}});var t=r(3117),a=r(102),o=(r(7294),r(3905)),i=r(6396),c=r(8215),l=["components"],u={title:"Docker Hardware Acceleration - NVENC",description:"Unmanic Installation - Docker Hardware Acceleration - NVENC",id:"hardware_accelerated_encoding_nvenc"},s=void 0,d={unversionedId:"advanced/hardware_accelerated_encoding_nvenc",id:"advanced/hardware_accelerated_encoding_nvenc",isDocsHomePage:!1,title:"Docker Hardware Acceleration - NVENC",description:"Unmanic Installation - Docker Hardware Acceleration - NVENC",source:"@site/docs/advanced/hardware_accelerated_encoding_nvenc.mdx",sourceDirName:"advanced",slug:"/advanced/hardware_accelerated_encoding_nvenc",permalink:"/docs/advanced/hardware_accelerated_encoding_nvenc",tags:[],version:"current",frontMatter:{title:"Docker Hardware Acceleration - NVENC",description:"Unmanic Installation - Docker Hardware Acceleration - NVENC",id:"hardware_accelerated_encoding_nvenc"},sidebar:"docs",previous:{title:"Plugin Manager CLI",permalink:"/docs/development/plugin_manager_cli"},next:{title:"Docker Hardware Acceleration - VAAPI",permalink:"/docs/advanced/hardware_accelerated_encoding_vaapi"}},p=[{value:"Overview",id:"overview",children:[],level:2},{value:"Running Unmanic with support for NVENC",id:"running-unmanic-with-support-for-nvenc",children:[],level:2}],m={toc:p};function f(e){var n=e.components,r=(0,a.Z)(e,l);return(0,o.kt)("wrapper",(0,t.Z)({},m,r,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"Unmanic supports hardware acceleration (HWA) of video decoding using FFmpeg. FFmpeg and Unmanic can support multiple hardware acceleration implementations such as nVidia NVENC and MediaCodec through Video Acceleration API's."),(0,o.kt)("p",null,"For more information on NVIDIA using FFmpeg official list, take a look ",(0,o.kt)("a",{parentName:"p",href:"https://developer.nvidia.com/ffmpeg"},"here"),"."),(0,o.kt)("p",null,"It is recommended to use the patched drivers ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/keylase/nvidia-patch"},"here")," as these will remove the restriction on maximum number of simultaneous NVENC video encoding sessions imposed by Nvidia to consumer-grade GPUs."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://developer.nvidia.com/video-encode-and-decode-gpu-support-matrix-new"},"Here")," is the official list of NVIDIA Graphics Cards for supported codecs."),(0,o.kt)("p",null,"To ensure you device is capable of running the NVENC encoders, run this command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'for i in encoders decoders filters; do     echo $i:; ffmpeg -hide_banner -${i} | egrep -i "npp|cuvid|nvenc|cuda|nvdec"; done\n')),(0,o.kt)("p",null,"You should see a list of available encoders and decoders."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"NOTE:\nThe minimum required NVIDIA driver version is 418.30 for this to work in Linux.")),(0,o.kt)("h2",{id:"running-unmanic-with-support-for-nvenc"},"Running Unmanic with support for NVENC"),(0,o.kt)("p",null,"To enable NVENC, you will need to run Unmanic on a device that supports it."),(0,o.kt)("p",null,"If you intend to use Unmanic inside a Docker container, you will also need to pass through the required devices to the container. "),(0,o.kt)("p",null,"An example of this is shown below:"),(0,o.kt)(i.Z,{defaultValue:"docker_run",values:[{label:"Docker run",value:"docker_run"},{label:"Docker-compose",value:"docker_compose"}],mdxType:"Tabs"},(0,o.kt)(c.Z,{value:"docker_run",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"  PUID=$(id -u)\n  PGID=$(id -g)\n\n  # CONFIG_DIR - Where you settings are saved\n  CONFIG_DIR=/config\n\n  # LIBRARY_DIR - The location/locations of your library\n  LIBRARY_DIR=/library\n\n  # CACHE_DIR - A tmpfs or and folder for temporary conversion files\n  CACHE_DIR=/tmp/unmanic\n  \n  # NVIDIA_VISIBLE_DEVICES - The GPUs that will be accessible to the container\n  NVIDIA_VISIBLE_DEVICES=all\n\n  docker run -ti --rm \\\n      -e PUID=${PUID} \\\n      -e PGID=${PGID} \\\n      -e NVIDIA_VISIBLE_DEVICES=${NVIDIA_VISIBLE_DEVICES} \\\n      --runtime=nvidia \\\n      -p 8888:8888 \\\n      -v ${CONFIG_DIR}:/config \\\n      -v ${LIBRARY_DIR}:/library \\\n      -v ${CACHE_DIR}:/tmp/unmanic \\\n      josh5/unmanic:latest\n"))),(0,o.kt)(c.Z,{value:"docker_compose",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},"  # Variables that will need to be changed:\n  #     <PUID>                            -  User id for folder/file permissions\n  #     <PGID>                            -  Group id for folder/file permissions\n  #     <NVIDIA_VISIBLE_DEVICES>          -  The GPUs that will be accessible to the container\n  #                                          Options: https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/user-guide.html#gpu-enumeration\n  #     <PATH_TO_CONFIG>                  -  Path where Unmanic will store config files\n  #     <PATH_TO_LIBRARY>                 -  Path where you store the files that Unmanic will scan\n  #     <PATH_TO_ENCODE_CACHE>            -  Cache path for in-progress encoding tasks\n  #\n\n  ---\n  version: '2.4'\n  services:\n    unmanic:\n      container_name: unmanic\n      image: josh5/unmanic:latest\n      ports:\n        - 8888:8888\n      environment:\n        - PUID=<PUID>\n        - PGID=<PGID>\n        - NVIDIA_VISIBLE_DEVICES=<NVIDIA_VISIBLE_DEVICES>\n      volumes:\n        - <PATH_TO_CONFIG>:/config\n        - <PATH_TO_LIBRARY>:/library\n        - <PATH_TO_ENCODE_CACHE>:/tmp/unmanic\n      runtime: nvidia       # For H/W transcoding using the NVENC encoder\n")))))}f.isMDXComponent=!0}}]);