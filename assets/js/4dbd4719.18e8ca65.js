"use strict";(self.webpackChunkunmanic_documentation=self.webpackChunkunmanic_documentation||[]).push([[6826],{3905:(e,n,r)=>{r.d(n,{Zo:()=>u,kt:()=>v});var a=r(7294);function t(e,n,r){return n in e?Object.defineProperty(e,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[n]=r,e}function o(e,n){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?o(Object(r),!0).forEach((function(n){t(e,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(r,n))}))}return e}function l(e,n){if(null==e)return{};var r,a,t=function(e,n){if(null==e)return{};var r,a,t={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],n.indexOf(r)>=0||(t[r]=e[r]);return t}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(t[r]=e[r])}return t}var c=a.createContext({}),s=function(e){var n=a.useContext(c),r=n;return e&&(r="function"==typeof e?e(n):i(i({},n),e)),r},u=function(e){var n=s(e.components);return a.createElement(c.Provider,{value:n},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var r=e.components,t=e.mdxType,o=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=s(r),m=t,v=d["".concat(c,".").concat(m)]||d[m]||p[m]||o;return r?a.createElement(v,i(i({ref:n},u),{},{components:r})):a.createElement(v,i({ref:n},u))}));function v(e,n){var r=arguments,t=n&&n.mdxType;if("string"==typeof e||t){var o=r.length,i=new Array(o);i[0]=m;var l={};for(var c in n)hasOwnProperty.call(n,c)&&(l[c]=n[c]);l.originalType=e,l[d]="string"==typeof e?e:t,i[1]=l;for(var s=2;s<o;s++)i[s]=r[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}m.displayName="MDXCreateElement"},5162:(e,n,r)=>{r.d(n,{Z:()=>i});var a=r(7294),t=r(6010);const o="tabItem_Ymn6";function i(e){let{children:n,hidden:r,className:i}=e;return a.createElement("div",{role:"tabpanel",className:(0,t.Z)(o,i),hidden:r},n)}},5488:(e,n,r)=>{r.d(n,{Z:()=>m});var a=r(7462),t=r(7294),o=r(6010),i=r(2389),l=r(7392),c=r(7094),s=r(2466);const u="tabList__CuJ",d="tabItem_LNqP";function p(e){const{lazy:n,block:r,defaultValue:i,values:p,groupId:m,className:v}=e,f=t.Children.map(e.children,(e=>{if((0,t.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})),h=p??f.map((e=>{let{props:{value:n,label:r,attributes:a}}=e;return{value:n,label:r,attributes:a}})),b=(0,l.l)(h,((e,n)=>e.value===n.value));if(b.length>0)throw new Error(`Docusaurus error: Duplicate values "${b.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`);const g=null===i?i:i??f.find((e=>e.props.default))?.props.value??f[0].props.value;if(null!==g&&!h.some((e=>e.value===g)))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${g}" but none of its children has the corresponding value. Available values are: ${h.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);const{tabGroupChoices:_,setTabGroupChoices:y}=(0,c.U)(),[I,w]=(0,t.useState)(g),A=[],{blockElementScrollPositionUntilNextRender:k}=(0,s.o5)();if(null!=m){const e=_[m];null!=e&&e!==I&&h.some((n=>n.value===e))&&w(e)}const P=e=>{const n=e.currentTarget,r=A.indexOf(n),a=h[r].value;a!==I&&(k(n),w(a),null!=m&&y(m,String(a)))},D=e=>{let n=null;switch(e.key){case"Enter":P(e);break;case"ArrowRight":{const r=A.indexOf(e.currentTarget)+1;n=A[r]??A[0];break}case"ArrowLeft":{const r=A.indexOf(e.currentTarget)-1;n=A[r]??A[A.length-1];break}}n?.focus()};return t.createElement("div",{className:(0,o.Z)("tabs-container",u)},t.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":r},v)},h.map((e=>{let{value:n,label:r,attributes:i}=e;return t.createElement("li",(0,a.Z)({role:"tab",tabIndex:I===n?0:-1,"aria-selected":I===n,key:n,ref:e=>A.push(e),onKeyDown:D,onClick:P},i,{className:(0,o.Z)("tabs__item",d,i?.className,{"tabs__item--active":I===n})}),r??n)}))),n?(0,t.cloneElement)(f.filter((e=>e.props.value===I))[0],{className:"margin-top--md"}):t.createElement("div",{className:"margin-top--md"},f.map(((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==I})))))}function m(e){const n=(0,i.Z)();return t.createElement(p,(0,a.Z)({key:String(n)},e))}},4300:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>m,frontMatter:()=>l,metadata:()=>s,toc:()=>d});var a=r(7462),t=(r(7294),r(3905)),o=r(5488),i=r(5162);const l={title:"Docker Hardware Acceleration - VAAPI",description:"Unmanic Installation - Docker Hardware Acceleration - VAAPI",id:"hardware_accelerated_encoding_vaapi"},c=void 0,s={unversionedId:"advanced/hardware_accelerated_encoding_vaapi",id:"advanced/hardware_accelerated_encoding_vaapi",title:"Docker Hardware Acceleration - VAAPI",description:"Unmanic Installation - Docker Hardware Acceleration - VAAPI",source:"@site/docs/advanced/hardware_accelerated_encoding_vaapi.mdx",sourceDirName:"advanced",slug:"/advanced/hardware_accelerated_encoding_vaapi",permalink:"/docs/advanced/hardware_accelerated_encoding_vaapi",draft:!1,tags:[],version:"current",frontMatter:{title:"Docker Hardware Acceleration - VAAPI",description:"Unmanic Installation - Docker Hardware Acceleration - VAAPI",id:"hardware_accelerated_encoding_vaapi"},sidebar:"docs",previous:{title:"Plugin Manager CLI",permalink:"/docs/development/plugin_manager_cli"},next:{title:"Docker-Compose SMB/CIFS mounts",permalink:"/docs/advanced/docker_compose_cifs_mounts"}},u={},d=[{value:"Overview",id:"overview",level:2},{value:"Running Unmanic with support for VAAPI",id:"running-unmanic-with-support-for-vaapi",level:2}],p={toc:d};function m(e){let{components:n,...r}=e;return(0,t.kt)("wrapper",(0,a.Z)({},p,r,{components:n,mdxType:"MDXLayout"}),(0,t.kt)("h2",{id:"overview"},"Overview"),(0,t.kt)("p",null,"Unmanic supports hardware acceleration (HWA) of video decoding using FFmpeg. FFmpeg and Unmanic can support multiple hardware acceleration implementations such as nVidia NVENC and MediaCodec through Video Acceleration API's."),(0,t.kt)("p",null,"VAAPI is a Video Acceleration API that uses libva to interface with local drivers to provide HWA."),(0,t.kt)("p",null,"You can find a list of supported codecs for VAAPI ",(0,t.kt)("a",{parentName:"p",href:"https://wiki.archlinux.org/index.php/Hardware_video_acceleration#Comparison_tables"},"here"),".\nBoth Intel iGPU and AMD GPU can use VAAPI."),(0,t.kt)("blockquote",null,(0,t.kt)("p",{parentName:"blockquote"},"NOTE:\nAMD GPU requires open source driver Mesa 20.1 or higher to support hardware decoding HEVC.")),(0,t.kt)("h2",{id:"running-unmanic-with-support-for-vaapi"},"Running Unmanic with support for VAAPI"),(0,t.kt)("p",null,"To enable VAAPI, you will need to run Unmanic on a device that supports it."),(0,t.kt)("p",null,"If you intend to use Unmanic inside a Docker container, you will also need to pass through the required devices to the container."),(0,t.kt)("p",null,"An example of this is shown below:"),(0,t.kt)(o.Z,{defaultValue:"docker_run",values:[{label:"Docker run",value:"docker_run"},{label:"Docker-compose",value:"docker_compose"}],mdxType:"Tabs"},(0,t.kt)(i.Z,{value:"docker_run",mdxType:"TabItem"},(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-bash"},"  PUID=$(id -u)\n  PGID=$(id -g)\n\n  # CONFIG_DIR - Where you settings are saved\n  CONFIG_DIR=/config\n\n  # LIBRARY_DIR - The location/locations of your library\n  LIBRARY_DIR=/library\n\n  # CACHE_DIR - A tmpfs or and folder for temporary conversion files\n  CACHE_DIR=/tmp/unmanic\n\n  docker run -ti --rm \\\n      -e PUID=${PUID} \\\n      -e PGID=${PGID} \\\n      --device=/dev/dri \\\n      -p 8888:8888 \\\n      -v ${CONFIG_DIR}:/config \\\n      -v ${LIBRARY_DIR}:/library \\\n      -v ${CACHE_DIR}:/tmp/unmanic \\\n      josh5/unmanic:latest\n"))),(0,t.kt)(i.Z,{value:"docker_compose",mdxType:"TabItem"},(0,t.kt)("pre",null,(0,t.kt)("code",{parentName:"pre",className:"language-yaml"},"  # Variables that will need to be changed:\n  #     <PUID>                            -  User id for folder/file permissions\n  #     <PGID>                            -  Group id for folder/file permissions\n  #     <PATH_TO_CONFIG>                  -  Path where Unmanic will store config files\n  #     <PATH_TO_LIBRARY>                 -  Path where you store the files that Unmanic will scan\n  #     <PATH_TO_ENCODE_CACHE>            -  Cache path for in-progress encoding tasks\n  #\n\n  ---\n  version: '2.4'\n  services:\n    unmanic:\n      container_name: unmanic\n      image: josh5/unmanic:latest\n      ports:\n        - 8888:8888\n      environment:\n        - PUID=<PUID>\n        - PGID=<PGID>\n      volumes:\n        - <PATH_TO_CONFIG>:/config\n        - <PATH_TO_LIBRARY>:/library\n        - <PATH_TO_ENCODE_CACHE>:/tmp/unmanic\n      devices:\n        - /dev/dri:/dev/dri       # For H/W transcoding using the VAAPI encoder\n")))))}m.isMDXComponent=!0}}]);